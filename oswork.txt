        - OS WORK MANUAL -

==============================================================================

・OS ワーク一覧表

$1c00   1.l     現在のプロセスにおけるメモリ最終アドレス+1
$1c04   1.l     〃                    メモリ先頭アドレス(PSP)
$1c08   1.w     inDOS フラグ(DOS コール再帰回数)
$1c0a   1.b     実行中の DOS コール番号(DOS コール再帰中は変更されない)
$1c0b   1.b     newfat 設定値(0/2)
$1c0c   1.w     _IOCTRL(11)第一引数:リトライ数
$1c0e   1.w     〃         第二引数:待機時間
$1c10   1.w     verify モード
$1c12   1.b     break モード
$1c13   1.b     CTRL-P フラグ(0:off -1:on)
$1c14   1.b     スレッド切り換え要求フラグ
$1c15   1.b     カレントドライブ番号
$1c16   1.b     stop key フラグ(bit7=1:trap #11 が呼ばれた bit0=1:shift+break)
$1c17   1.b     trap #10 実行フラグ
$1c18   1.l     trap #10 実行時の d0.l
$1c1c   1.l     最終デバイスドライバのデバイスヘッダのアドレス
$1c20   1.l     Human68k のプロセス管理ポインタのアドレス(=先頭のメモリブロック)
$1c24   1.l     Human68k が使用しているメモリの最終アドレス+1(この値を 8KB
                境界に整合したアドレスまでがスーパバイザ領域に設定される)
$1c28   1.l     現在のプロセスのプロセス管理ポインタのアドレスを格納しているワー
                クのアドレス(Human68k ver3.02 では $13d0a)
$1c2c   1.l     標準 FCB(6以上のハンドル)の FCB index table のアドレス
$1c30   1.l     FCB table のアドレス
$1c34   1.l     ディスク入出力バッファのアドレス
$1c38   1.l     カレントディレクトリテーブルのアドレス
$1c3c   1.l     DPB テーブルのアドレス
$1c40   1.l     share 管理構造体のアドレス
$1c44   1.l     common 領域のアドレス
$1c48   1.l     使用している common 領域の最終アドレス+1
$1c4c   1.l     common 領域末尾のアドレス
$1c50   1.l     スレッド管理構造体テーブルのアドレス
$1c54   1.l     現在のスレッドのスレッド管理構造体のアドレス
$1c58   1.w     最大スレッド数-1(process 設定値)
$1c5a   1.w     現在生成されているスレッド数
$1c5c   1.l     DOS コール分岐直前の ssp の値(DOS コール再帰中は変更されない)
$1c60   1.w     アボート時の sr
$1c62   1.l     〃           ssp
$1c66   1.l     Human68k 起動前の trap #11 処理アドレス
$1c6a   1.l     〃                trap #10 〃
$1c6e   1.w     最大ハンドルファイル(files 設定値+2)
$1c70   1.w     buffers 第二引数:セクタサイズ
$1c72   1.b     〃      第一引数:バッファ数
$1c73   1.b     lastdrive 設定値
$1c74   1.b     最大ドライブ数(26)
$1c75   1.b     接続ドライブ数-1(無接続の場合は 0)
$1c76   1.w     share 第二引数:ファイル数
$1c78   1.w     〃    第一引数:ロック領域数
$1c7a   1.l     〃    管理構造体一個当りのバイト数(lock*12+92)
$1c7e   26.b    ドライブ交換テーブル
$1c98   1.l     DOS コール中にオープンした FCB(アボート時にクローズされる)
$1c9c   1.l     〃                        ファイルハンドル
$1ca0   1.b     _EXEC 遷移状態フラグ(0:load 中ではない -1:load or loadexec 中
                -2:プロセス生成中 -3:pspset 中) 
$1ca1   1.b     _EXEC のモジュール番号
$1ca2   1.b     ins key モード(0:off -1:on)
$1ca3   1.b     エラー処理実行中フラグ(0:実行中 -1:終了)
$1ca4   1.l     標準入力からの _READ で使用する行入力バッファの読み込みポインタ
$1ca8   1.w     〃                                             残りバイト数
$1caa   1.l     _EXEC 実行中のプロセスのプロセス管理ポインタのアドレス
$1cae   1.l     プロセス終了コード(上位ワードが 1 なら常駐終了)
$1cb2   1.l     _EXEC 実行中のコマンドラインのアドレス
$1cb6   1.l     CLOCK デバイスのデバイスヘッダのアドレス
$1cba   1.b     fflush モード(0:on 1:off)
$1cbb   1.b     (未使用)
$1cbc   1.w     ブレークするキーコード(CTRL-C)
$1cbe   1.w     プリンタ出力をオフにするコード:CTRL-N(上位バイトが 1 で無効)
$1cc0   1.w     〃            切り換えるコード:CTRL-P(〃)
$1cc2   1.w     画面への出力を再開するコード:CTRL-Q(参照されない)
$1cc4   1.w     〃            停止するコード:CTRL-S(上位バイトが 1 で無効)

==============================================================================

・DOS コール分岐直前のスタック内容

offset  size
$00(0)  1.l     d1
$04(4)  1.l     d2
$08(8)  1.l     d3
$0c(12) 1.l     d4
$10(16) 1.l     d5
$14(20) 1.l     d6
$18(24) 1.l     d7
$1c(28) 1.l     a0
$20(32) 1.l     a1
$24(36) 1.l     a2
$28(40) 1.l     a3
$2c(44) 1.l     a4
$30(48) 1.l     a5
$34(52) 1.l     a6
$38(56) 1.w     sr
$3a(58) 1.l     pc
$3e(62) 1.w     ベクタ番号(68010以降のみ)

　スタックの先頭アドレスは $1c5c に保存されている。

==============================================================================

・ディスク I/O バッファ

offset  size
$00(0)  1.l     次の構造体のアドレス
$04(4)  1.b     ドライブ番号
$05(5)  3.b     セクタ番号
$08(8)  1.l     前の構造体のアドレス
$0c(12) 1.b     状態フラグ(bit 7=1:書き込み中   bit 6=1:FAT
                           bit 5=1:ディレクトリ bit 4=1:ファイル)
$0d(13) 3.b     DPB
$10(16) ???.b   データバッファ(buffers 第二引数で指定されたサイズ)

　一個当り 16 バイトのヘッダと buffers 第二引数で指定した大きさのバッファから
なる構造体が buffers 第一引数で指定した数だけ並び、その先頭アドレスが $1c34 に
保存されている。0 バイト目と 8 バイト目のデータは最長不使用法による双方向リス
トである。
　なお、Human68k version 3 ではディスク入出力が OS から独立しているので、この
バッファを直接参照/変更してはならない。

==============================================================================

・カレントディレクトリテーブル

offset  size
$00(0)   2.b    ドライブ名"d:"
$02(2)  62.b    パス名(パスデリミタは $09)
                仮想ドライブの場合は割り当てディレクトリ＋カレントディレクトリ
$40(64)  1.l    (未使用)
$44(68)  1.b    〃
$45(69)  1.b    割り当て状態($00:未使用
                             $40:実ドライブ
                             $50:仮想ドライブ
                             $60:仮想ディレクトリ)
$46(70)  1.l    DPB のアドレス
$4a(74)  1.w    カレントディレクトリの先頭 FAT 番号(0:未アクセス -1:初期化直後)
$4c(76)  1.w    ルートディレクトリのパス名の長さ(実ドライブ = 2)

　一個当り 78 バイトの表が 26 個並び、その先頭アドレスが $1c38 に保存されてい
る。パス名は必ずパスデリミタ($09)から始まり、ルートディレクトリだけの場合を除
いて末尾には付かない。

　未使用ドライブの DPB のアドレスは不定な値がセットされているが、一度仮想ドラ
イブ/ディレクトリを割り当てて解除すると -1 になる。

==============================================================================

・ドライブ交換テーブル

offset  size
0       1.b     論理ドライブ番号 0 に対応する物理ドライブ番号
1       1.b             〃       1 〃
…      …
24      1.b             〃      24 〃
25      1.b             〃      25 〃

　一個当り 1 バイトの表が 26 個並び、その先頭アドレスは $1c7e である。

※物理ドライブ番号 = デバイス組み込み順に与えられるドライブ番号
　論理ドライブ番号 = ユーザが A:～Z: で指定するドライブ番号

==============================================================================

・ドライブパラメータブロック

offset  size    ●ローカルドライブ/リモートドライブ共通
$00(0)  1.b     ドライブ番号
$01(1)  1.b     ユニット番号
$02(2)  1.l     デバイスドライバ(デバイスヘッダ)のアドレス
$06(6)  1.l     次の DPB のアドレス
$0a(10) 1.w     1 セクタ当りのバイト数

                ●ローカルドライブ専用
$0c(12) 1.b     1 クラスタ当りのセクタ数-1
$0d(13) 1.b     クラスタ→セクタのシフト数
                bit 7=1 なら 16bit Intel FAT
$0d(14) 1.w     FAT の先頭セクタ番号
$10(16) 1.b     FAT 領域の個数
$11(17) 1.b     一個の FAT 領域当りのセクタ数
$12(18) 1.w     ルートディレクトリに入るファイルの個数
$14(20) 1.w     データ領域の先頭セクタ番号
$16(22) 1.w     総クラスタ数+1
$18(24) 1.w     ルートディレクトリの先頭セクタ番号
$1a(26) 1.b     メディアバイト
$1b(27) 1.b     セクタ→バイトのシフト数
$1c(28) 1.w     FAT 検索開始位置

                ●DIRSCH 空きエントリ検索用
$1e(30) 1.l     対象ディレクトリの先頭 FAT 番号
$22(34) 1.w     1 クラスタ当りのセクタ数-1
$24(36) 1.l     次回検索開始位置のセクタ番号
$28(40) 1.w     注目クラスタ内の残りセクタ数-1

                ●DIRSCH ファイル検索用
$2a(42) 1.l     対象ディレクトリの先頭 FAT 番号
$2e(46) 1.w     1 クラスタ当りのセクタ数-1
$30(48) 1.l     次回検索開始位置のセクタ番号
$34(52) 1.w     注目クラスタ内の残りセクタ数-1
$36(54) 1.w     次回検索開始位置のオフセット(32 の倍数)

　DPB にはローカルドライブ用のものとリモートドライブ用の二種類があり、それぞれ
サイズが違う。リモートドライブ用の DPB の方が小さく、ごく僅かな情報だけが格納
されている。

　1 セクタ当りのバイト数が 0 以外であればローカルドライブの DPB で、サイズは
56 バイト。1 セクタ当りのバイト数が 0 であればリモートドライブの DPB で、サイ
ズは 12 バイト。一個当り 56 又は 12 バイトの DPB が認識したドライブ数だけ存在
し、その先頭アドレスが $1c3c に保存されている。連続したアドレスに作成されるわ
けではないので、特定の DPB を得る為には以下の方法で計算する必要がある。

・DPB の収得方法(Human68k version 2/3 で共通)

1) DOS 上でのドライブ番号(A=0、B=1、…、Z=25)を収得し、A とする。
2) Human68k のワーク (0x1c7e+A).b を収得し、B とする。これは OS 内部でのドライ
　 ブ番号である。
3) Human68k のワーク (0x1c38).l を収得し、C とする。
4) (C+(0x4e*B)+0x46).l を収得し、D とする。
5) D がドライブ番号 A の DPB へのポインタとなる。

※ 先頭から順に DPB をたどる方法では、GRAD.r などで途中の未使用ドライブを飛ば
   して DPB を繋げた場合に対応できない。

==============================================================================

・ファイルハンドル複写テーブル

offset  size
0       1.b     論理ファイルハンドル(_DUP0 でのみ変更される)。
                特に参照される事はない。
1       1.b     物理ファイルハンドル(_DUP/_DUP0/_DUP2で変更される)。
                2 バイトとも $ff なら対応する論理ファイルハンドルは未使用。

　一個当り 2 バイトの表が(files 指定値-3)個並び、その先頭アドレスが $1c2c に保
存されている(-3 は標準ファイルハンドルの分で -5、辞書ハンドルの分で +2 による)。
基本的に、論理ファイルハンドルは 6 以上でテーブルの要素番号を示す。

※物理ファイルハンドル = 先頭の FCB から順に付けられるファイルハンドル
　論理ファイルハンドル = ユーザが使用するファイルハンドル

==============================================================================

・ファイルコントロールブロック

offset  size
$00(0)  1.b     この FCB に対応しているファイルハンドルの数
$01(1)  1.b     デバイス情報(bit 7=0 の時は bit 4～0 でドライブ名を保持する)
                        bit 7   0:ブロックデバイス 1:キャラクタデバイス
                        bit 6   更新フラグ
                        bit 5   0:Local 1:Remote  ブロックデバイスの場合
                        bit 5   0:COOKED 1:RAW  ┐
                        bit 3   CLOCK   デバイス│
                        bit 2   NUL     〃      │キャラクタデバイスの場合
                        bit 1   標準出力〃      │
                        bit 0   標準入力〃      ┘
$02(2)  1.l     ブロックデバイス   : DPB のアドレス
                キャラクタデバイス : デバイスドライバへのポインタ
$06(6)  1.l     ファイルポインタ
$0a(10) 1.l     排他制御情報へのポインタ
$0e(14) 1.b     アクセスモード
$0f(15) 1.b     ディレクトリ上の位置(セクタ先頭からの個数:0～31)
                (キャラクタデバイスでは未使用)
$10(16) 1.b     アクセス中のクラスタ中のセクタ
$11(17) 1.b     (未使用)
$12(18) 1.w     アクセス中のクラスタ番号
$14(20) 1.l     アクセス中のセクタ番号
$18(24) 1.l     I/O バッファ先頭
$1c(28) 1.l     対応するディレクトリエントリのセクタ番号
                (キャラクタデバイスでは未使用)
$20(32) 1.l     最終アクセスポインタ(_SEEK しなければファイルポインタと同じ値)
$24(36) 8.b     ファイル名１(余白は $20)
$2c(44) 3.b     ファイル名拡張子(〃)
$2f(47) 1.b     ファイル属性
$30(48) 10.b    ファイル名２(〃)
$3a(58) 1.w     最終更新時刻
$3c(60) 1.w     最終更新年月日
$3e(62) 1.w     先頭の FAT 番号
$40(64) 1.l     ファイルサイズ
$44(68) 7.l     FAT キャッシュ(上位word:先頭からのクラスタ数 下位word:FAT 番号)

　一個当り 96 バイトの表が(files 指定値-3)個並び、その先頭アドレスが $1c30 に
保存されている。ファイルハンドル 0～5 の FCB は Human68k の内部データエリアに
静的に確保されている。

　68 バイト目からの 7 組のキャッシュは、ファイル先頭から 1/8、2/8、…、7/8 の
位置に相当するクラスタ数と FAT 番号が書き込まれる(0/8 は 62 バイト目が対応する)。
アクセス順序によっては n/8 ちょうどのクラスタ位置の FAT が得られないが、その場
合は n/8 ≦ N/8 ＜ (n+1)/8 を満たすクラスタ位置 N について FAT 番号を保存する。
アクセスを繰り返せば、最終的に 1/8、2/8、…、7/8 の位置に落ち着く。

==============================================================================

・ファイル排他制御管理構造体

offset  size
$00(0)  1.b     対応する FCB の数(0 なら未使用)
$01(1)  1.b     最初にオープンした時のアクセスモード
$02(2)  1.w     ロック数
$04(4)  88.b    NAMESTS バッファ
$5c(92) ???.b   share 第二引数で指定した数のロック構造体

　92 バイトのヘッダに、一個当り 12 バイトのロック構造体が share 第二引数で指定
されただけ並んだ構造体が、share 第一引数で指定した数だけ並び、その先頭アドレス
が $1c40 に保存されている。share 第一/第二引数をそれぞれ SHARE/LOCK とすると、
全体のサイズは (92+LOCK*12)*SHARE となる。

・ロック構造体

offset  size
0       1.l     ロック開始位置
4       1.l     ロックするバイト数
8       1.l     FCB

　ファイルのロック領域を設定するためのバッファで、ファイル排他制御管理構造体の
末尾に詰めて書き込まれる。

==============================================================================

・メモリ管理ポインタ

offset  size
$00(0)  1.l     前のメモリ管理ポインタ(0 で先頭)
$04(4)  1.l     親プロセスのメモリ管理ポインタ(0 で親はいない)
$08(8)  1.l     このメモリブロックの最終アドレス+1
$0c(12) 1.l     次のメモリ管理ポインタ(0 で末尾)

　メモリブロック毎に、その先頭に作成される 16 バイトの構造体である。先頭のメモ
リブロックは Human68k 内部のスーパーバイザ領域に存在する。

　4 バイト目(メモリを確保したプロセス)の最上位バイトで、そのメモリブロックの属
性を表わす。

        $ff     常駐プロセス(KEEP)
        $fe     不明(MEMDRV)
        $fd     サブメモリブロック

・プロセス管理ポインタ

offset   size
$00(0)    4.l   (メモリ管理ポインタ)
$10(16)   1.l   環境のアドレス(-1 なら確保されていない)
$14(20)   1.l   終了時の戻りアドレス
$18(24)   1.l   CTRL+C により中断された際の戻りアドレス
$1c(28)   1.l   エラーにより中断された際の戻りアドレス
$20(32)   1.l   コマンドラインのアドレス
$24(36)  12.b   プロセスのファイルハンドラの使用状況
                ($24～$2f の bit 0～7 の順で使用中 = 1 となる)
$30(48)   1.l   BSS の先頭アドレス
$34(52)   1.l   ヒープの先頭アドレス(BSS と同じ)
$38(56)   1.l   初期スタックアドレス(ヒープの終わり+1)
$3c(60)   1.l   親プロセスの USP
$40(64)   1.l   親プロセスの SSP
$44(68)   1.w   親プロセスの SR
$46(70)   1.w   アボート時の SR
$48(72)   1.l   アボート時の SSP
$4c(76)   1.l   trap #10 のベクタ
$50(80)   1.l   trap #11 のベクタ
$54(84)   1.l   trap #12 のベクタ
$58(88)   1.l   trap #13 のベクタ
$5c(92)   1.l   trap #14 のベクタ
$60(96)   1.l   shell 起動フラグ(0:通常の起動 -1:shell として起動)
$64(100)  1.b   モジュール番号
$65(101)  3.b   (未使用)
$68(104)  1.l   ロードした子プロセスのプロセス管理ポインタ
$6a(108)  5.l   (未使用)
$80(128)  2.b   実行ファイルのドライブ名
$82(130) 66.b   実行ファイルのパス名
$c4(196) 24.b   実行ファイルのファイル名
$dc(220)  9.l   (未使用)

　プロセス毎にそのメモリブロックの先頭に作成される、プロセス情報を保有する為の
256 バイトの構造体(メモリ管理ポインタも含む)。

==============================================================================

・スレッド管理構造体

offset   size
$00(0)    1.l   次のスレッド管理構造体のアドレス
$04(4)    1.b   ウェイトフラグ(0:Normal -1:Wait)
$05(5)    1.b   減算カウンタ
$06(6)    1.b   カウンタ初期値
$07(7)    1.b   DOS コール番号
$08(8)    1.l   PSP のアドレス
$0c(12)   1.l   usp
$10(16)   8.l   d0-d7
$30(48)   7.l   a0-a6
$4c(76)   1.w   sr
$4e(78)   1.l   pc
$52(82)   1.l   ssp
$56(86)   1.w   INDOS フラグ(OS 実行中レベル)
$58(88)   1.l   INDOS ポインタ(OS 実行中スタック)
$5c(92)   1.l   スレッド間通信バッファのアドレス
$60(96)  16.b   スレッド名
$70(112)  1.l   待機時間残量(ミリ秒単位)
$74(116)  1.l   プロセスのメモリブロック先頭アドレス
$78(120)  1.l           〃              最終アドレス+1

　一個当り 124 バイトの表が、process の第一引数で指定した数だけ並び、その先頭
アドレスが $1c50 に保存されている。先頭の表が Human68k 及び DOS _EXEC によって
起動された子プロセスで使われるもので、これがメインスレッドとなる。

==============================================================================

・コモン領域

　コモン領域は Human68k から一つの領域として確保され、その先頭アドレスが $1c44
に保存されている。個々のコモン領域は、ユーザから要求された時に始めて確保され、
データ領域の先頭に 32 バイトのヘッダが作られる。ヘッダの構造は以下の通り。

offset  size
$00(0)   1.l    この領域の全体のバイト数
$04(4)  12.b    この領域の識別名
$10(16)  1.l    この領域のデータサイズ
$14(20)  1.l    ロック開始位置までのオフセット
$18(24)  1.l    ロックするバイト数
$1c(28)  1.l    この領域を確保したプロセスの PSP+16

　特定のコモン領域を検索するには、先頭から順に識別名を比較して行かなければなら
ない。なお、コモン領域を削除すると以後の領域が前方に移動されて隙間が詰められる。

==============================================================================
